/*
 * This Spock specification was generated by the Gradle 'init' task.
 */
package io.seqera.migtool

import java.nio.file.Files
import io.seqera.migtool.resources.ClassFromJarWithResources

import spock.lang.Specification

class MigToolTest extends Specification {


    def 'should init migtool' () {
        given:
        def tool = new MigTool()
            .withDriver('org.h2.Driver')
            .withDialect('h2')
            .withUrl('jdbc:h2:mem:test;DB_CLOSE_DELAY=-1') // use DB_CLOSE_DELAY to avoid losing data when the jdbc connection is close
            .withUser('sa')
            .withPassword('')
            .withLocations('classpath:test')

        when:
        tool.init()
        then:
        tool.schema == 'PUBLIC'
        tool.catalog == 'TEST'
        and:
        def conn = tool.getConnection()
        conn != null
        and:
        !tool.existTable(conn, MigTool.MIGTOOL_TABLE)

        when:
        tool.createIfNotExists()
        then:
        tool.existTable(conn, MigTool.MIGTOOL_TABLE)

        cleanup:
        conn?.close()
    }


    def 'should apply local file migration' () {
        given:
        def folder = Files.createTempDirectory('test')
        folder.resolve('V01__file1.sql').text = 'create table XXX ( col1 varchar(1) ); '
        folder.resolve('V02__file2.sql').text = 'create table YYY ( col2 varchar(2) ); create table ZZZ ( col3 varchar(3) );'
        folder.resolve('x03__xyz.txt').text = 'This field should be ignored'
        and:

        def tool = new MigTool()
                .withDriver('org.h2.Driver')
                .withDialect('h2')
                .withUrl('jdbc:h2:mem:test')
                .withUser('sa')
                .withPassword('')
                .withLocations("file:$folder")

        when:
        tool.init()
        and:
        tool.scanMigrations()
        then:
        tool.migrationEntries.size()==2
        and:
        with(tool.migrationEntries[0]) {
            rank == 1
            script == 'V01__file1.sql'
            statements == ['create table XXX ( col1 varchar(1) );']
        }
        and:
        with(tool.migrationEntries[1]) {
            rank == 2
            script == 'V02__file2.sql'
            statements == ['create table YYY ( col2 varchar(2) );', 'create table ZZZ ( col3 varchar(3) );']
        }

        when:
        tool.createIfNotExists()
        tool.apply()
        then:
        def conn = tool.getConnection()
        conn != null
        and:
        tool.existTable(conn, 'XXX')
        tool.existTable(conn, 'YYY')
        tool.existTable(conn, 'ZZZ')
        and:
        !tool.existTable(conn, 'FOO')

        cleanup:
        conn?.close()
        folder?.deleteDir()
    }

    def 'should apply class path migration' () {
        given:
        def tool = new MigTool()
                .withDriver('org.h2.Driver')
                .withDialect('h2')
                .withUrl('jdbc:h2:mem:test')
                .withUser('sa')
                .withPassword('')
                .withLocations("classpath:db/mariadb")

        when:
        tool.init()
        and:
        tool.scanMigrations()
        then:
        tool.migrationEntries.size()==2
        and:
        with(tool.migrationEntries[0]) {
            rank == 1
            script == 'V01__maria1.sql'
            statements == ['create table XXX ( col1 varchar(1) );']
        }
        and:
        with(tool.migrationEntries[1]) {
            rank == 2
            script == 'V02__maria2.sql'
            statements == ['create table YYY ( col2 varchar(2) );', 'create table ZZZ ( col3 varchar(3) );']
        }

        when:
        tool.createIfNotExists()
        tool.apply()
        then:
        def conn = tool.getConnection()
        conn != null
        and:
        tool.existTable(conn, 'XXX')
        tool.existTable(conn, 'YYY')
        tool.existTable(conn, 'ZZZ')
        and:
        !tool.existTable(conn, 'FOO')

        cleanup:
        conn?.close()
    }

    def 'should apply class path migration with custom pattern' () {
        given:
        def tool = new MigTool()
                .withDriver('org.h2.Driver')
                .withDialect('h2')
                .withUrl('jdbc:h2:mem:test')
                .withUser('sa')
                .withPassword('')
                .withLocations("classpath:db/mariadb")
                .withPattern(/v(\d\d)-.+/)

        when:
        tool.init()
        and:
        tool.scanMigrations()
        then:
        tool.migrationEntries.size()==1
        and:
        with(tool.migrationEntries[0]) {
            rank == 1
            script == 'v01-foo.txt'
            statements == ['create table CUSTOM ( col4 varchar(4) );']
        }
        
    }

    def 'should apply migration coming from a jar file' () {
        given:
        def tool = new MigTool()
                .withDriver('org.h2.Driver')
                .withDialect('h2')
                .withUrl('jdbc:h2:mem:test')
                .withUser('sa')
                .withPassword('')
                .withClassLoader(ClassFromJarWithResources.classLoader)
                .withLocations("classpath:db/migrations")

        when:
        tool.init()
        and:
        tool.scanMigrations()
        then:
        tool.migrationEntries.size()==2
        and:
        with(tool.migrationEntries[0]) {
            rank == 1
            script == 'V01__file1.sql'
            statements == ['create table XXX ( col1 varchar(1) );']
        }
        and:
        with(tool.migrationEntries[1]) {
            rank == 2
            script == 'V02__file2.sql'
            statements == ['create table YYY ( col2 varchar(2) );', 'create table ZZZ ( col3 varchar(3) );']
        }

        when:
        tool.createIfNotExists()
        tool.apply()
        then:
        def conn = tool.getConnection()
        conn != null
        and:
        tool.existTable(conn, 'XXX')
        tool.existTable(conn, 'YYY')
        tool.existTable(conn, 'ZZZ')
        and:
        !tool.existTable(conn, 'FOO')

        cleanup:
        conn?.close()
    }

}
