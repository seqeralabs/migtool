/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.seqera.migtool;

import groovy.lang.Binding;
import groovy.lang.Closure;
import groovy.lang.GroovyShell;
import groovy.sql.Sql;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Pattern;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Implement a simple migration tool inspired to Flyway
 *
 * @author Paolo Di Tommaso
 */

public class MigTool {

    static private final String SOURCE_CLASSPATH = "classpath:";
    static private final String SOURCE_FILE = "file:";

    public static int BACK_OFF_BASE = 3;
    public static int BACK_OFF_DELAY = 250;

    private static final Logger log = LoggerFactory.getLogger(MigTool.class);

    static final String MIGTOOL_TABLE = "MIGTOOL_HISTORY";

    private final Driver driver;
    private final String url;
    private final String user;
    private final String password;
    private final Dialect dialect;
    private final String locations;
    private final ClassLoader classLoader;
    private final Pattern pattern;
    private String schema;
    private String catalog;
    private final List<MigRecord> migrationEntries;
    private final List<MigRecord> patchEntries;
    private final List<MigRecord> overrideEntries;

    private MigTool(Builder builder) {
        this.driver = builder.driver;
        this.url = builder.url;
        this.user = builder.user;
        this.password = builder.password;
        this.dialect = builder.dialect;
        this.locations = builder.locations;
        this.classLoader = builder.classLoader;
        this.pattern = builder.pattern;
        this.migrationEntries = new ArrayList<>();
        this.patchEntries = new ArrayList<>();
        this.overrideEntries = new ArrayList<>();
    }

    /**
     * Main application entry point
     */
    public MigTool run() {
        init();
        ClassLoader previous = null;
        if( classLoader!=null ) {
            previous = Thread.currentThread().getContextClassLoader();
            Thread.currentThread().setContextClassLoader(classLoader);
        }

        try {
            createIfNotExists();
            scanMigrations();
            apply();
        } finally {
            if( previous!=null ) {
                Thread.currentThread().setContextClassLoader(previous);
            }
        }
        return this;
    }

    protected Connection getConnection() throws SQLException {
        return getConnection(0);
    }

    protected Connection getConnection(int maxRetries) throws SQLException {
        int errorCount=0;
        while( true ) {
            try {
                return DriverManager.getConnection(url, user, password);
            }
            catch (SQLException e) {
                if( errorCount++ >= maxRetries )
                    throw e;

                long delay = Math.round(Math.pow(BACK_OFF_BASE, errorCount)) * BACK_OFF_DELAY;
                log.debug("Got connection error={} - Waiting {}ms and retry (errorCount={})", e, delay, errorCount);
                try {Thread.sleep(delay);} catch (InterruptedException t) { log.debug("Got InterruptedException: {} - Ignoring it",e.getMessage()); }
            }
        }
    }

    List<MigRecord> getMigrationEntries() {
        return migrationEntries;
    }

    List<MigRecord> getPatchEntries() {
        return patchEntries;
    }

    List<MigRecord> getOverrideEntries() {
        return overrideEntries;
    }

    /**
     * Validate the expected input params and open the connection with the DB
     */
    protected void init() {
        validateAttributes();
        loadDriver();
        loadSchemaAndCatalog();
    }

    private void validateAttributes() {
        if( dialect==null )
            throw new IllegalStateException("Missing 'dialect' attribute");
        if( url==null || url.isEmpty() )
            throw new IllegalStateException("Missing 'url' attribute");
        if( driver==null )
            throw new IllegalStateException("Missing 'driver' attribute");
        if( user==null || user.isEmpty() )
            throw new IllegalStateException("Missing 'user' attribute");
        if( password==null )
            throw new IllegalStateException("Missing 'password' attribute");
        if( !Arrays.asList(Dialect.values()).contains(dialect) )
            throw new IllegalStateException("Unsupported dialect: " + dialect);
        if( locations==null )
            throw new IllegalStateException("Missing 'locations' attribute");
    }

    private void loadDriver() {
        try {
            Class.forName(driver.toString());
        }
        catch (ClassNotFoundException e) {
            throw new IllegalStateException("Unable to find driver class: " + driver, e);
        }
    }

    private void loadSchemaAndCatalog() {
        try( Connection conn = getConnection() ) {
            if( conn == null )
                throw new IllegalStateException("Unable to acquire DB connection");

            // retrieve the database schema
            if( schema==null || schema.isEmpty() ) {
                schema = conn.getSchema();
            }
            if( catalog==null || catalog.isEmpty() ) {
                catalog = conn.getCatalog();
            }
            if ( catalog==null && schema==null ) {
                log.warn("Unable to determine current DB catalog and schema attributes");
            }
        }
        catch (SQLException e) {
            throw new IllegalStateException("Unable to connect DB instance: " + url, e);
        }
    }

    protected boolean existTable(Connection connection, String tableName) throws SQLException {
        ResultSet res = connection
                .getMetaData()
                .getTables(catalog, schema, tableName, new String[] {"TABLE"});
        boolean result = res.next();
        log.debug("Checking existence of DB table={}; catalog={}; schema={}; exist={} rs={}", tableName, catalog, schema, result, dumpResultSet(result, res));
        return result;
    }

    protected String dumpResultSet(boolean hasData, ResultSet rs)  {
        if( !hasData )
            return "n/a";

        StringBuilder result = new StringBuilder();

        try {
            result.append( "{cols:");
            final int cols=rs.getMetaData().getColumnCount();
            for( int i=1; i<=cols; i++ ) {
                if( i>1 ) result.append(",");
                result.append(rs.getMetaData().getColumnName(i));
            }
            result.append( "}; ");

            int row=0;
            do {
                row++;
                result.append("{row").append(row).append(":");
                for( int i=1; i<=cols; i++ ) {
                    if( i>1 ) result.append(",");
                    result.append( String.valueOf(rs.getObject(i)).replaceAll("\n"," ") );
                }
                result.append( "}; ");
            } while( rs.next() );

            return result.toString();
        }
        catch (Exception e) {
            log.warn("Unable to dump result set", e);
            return null;
        }
    }

    /**
     * Create the support Migtool DB table if it does not exist
     */
    protected void createIfNotExists() {
        try (Connection conn = getConnection()) {
            if( !existTable(conn, MIGTOOL_TABLE) ) {
                log.info("Creating MigTool schema using dialect: {}", dialect.toString());
                String schema = Helper.getResourceAsString("/schema/" + dialect.toString() + ".sql");
                try ( Statement stm = conn.createStatement() ) {
                    stm.execute(schema);
                }
                log.info("Created");
            }
        } catch (SQLException e) {
            throw new IllegalStateException("Unable to create MigTool schema -- cause: " + e.getMessage(), e);
        }
    }

    /**
     * Look for the migration file in the specified locations, either
     * a file system directory or classpath resources
     */
    protected void scanMigrations() {
        if( locations.startsWith(SOURCE_CLASSPATH) ) {
            String path = locations.substring(SOURCE_CLASSPATH.length());
            Set<String> files = Helper.getResourceFiles(path);
            for( String it : files ) {
                MigRecord entry = MigRecord.parseResourcePath(it, pattern);
                if( entry==null ) {
                    log.warn("Invalid migration source file: " + it);
                }
                else {
                    addEntry(entry);
                }
            }
            // sort
            Collections.sort(this.migrationEntries);
        }
        else if( locations.startsWith(SOURCE_FILE)) {
            String path = locations.substring(SOURCE_FILE.length());
            try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get(path))) {
                for (Path it : stream) {
                    MigRecord entry = MigRecord.parseFilePath(it, pattern);
                    if (entry == null) {
                        log.warn("Invalid migration source file: " + it);
                    } else {
                        addEntry(entry);
                    }
                }
                Collections.sort(this.migrationEntries);
            } catch (IOException e) {
                throw new IllegalArgumentException("Unable to list files from location: " + locations + " -- cause: " + e.getMessage(), e);
            }
        }
        else {
            throw new IllegalArgumentException("Invalid locations prefix: " + locations);
        }

        log.debug("Scanned {} migration files, {} override files and {} patch files", migrationEntries.size(), overrideEntries.size(), patchEntries.size());
        if (overrideEntries.size() != patchEntries.size())
            throw new IllegalArgumentException("Sum of patch and override files doesn't match. For each patch file there has to be created override file.");
    }

    private void addEntry(MigRecord entry) {
        if(entry.isOverride())
            this.overrideEntries.add(entry);
        else if(entry.isPatch())
            this.patchEntries.add(entry);
        else
            this.migrationEntries.add(entry);
    }

    /**
     * Apply the migration files
     */
    protected void apply() {
        if(migrationEntries.isEmpty()) {
            log.info("No DB migrations found");
        }

        try {
            for( MigRecord it : migrationEntries) {
                applyMigration(it);
            }
        } catch (SQLException e) {
            throw new IllegalStateException("Unable perform migration -- cause: "+e.getMessage(), e);
        }
    }

    protected void checkRank(MigRecord entry) {
        try(Connection conn=getConnection(); Statement stm = conn.createStatement()) {
            String rank = dialect.isPostgres()  ? "rank" : "`rank`";
            String sql = String.format("select max(%s) from %s", rank, MIGTOOL_TABLE);
            ResultSet rs = stm.executeQuery(sql);
            int last = rs.next() ? rs.getInt(1) : 0;
            int expected = last+1;
            if( entry.rank != expected) {
                throw new IllegalStateException(String.format("Invalid migration -- Expected: %d; current rank: %d; migration script: %s", expected, entry.rank, entry.script));
            }
        } catch (SQLException e) {
            throw new IllegalStateException("Unable perform migration -- cause: "+e.getMessage(), e);
        }
    }

    MigRecord findPatchRecord(MigRecord entry) {
        return findRelatedRecordInCollection(patchEntries, entry);
    }

    MigRecord findOverrideRecord(MigRecord entry) {
        return findRelatedRecordInCollection(overrideEntries, entry);
    }

    private MigRecord findRelatedRecordInCollection(List<MigRecord> records, MigRecord entry) {
        return records.stream()
                .filter(e -> e.rank == entry.rank)
                .findFirst()
                .orElse(null);
    }

    protected void applyMigration(MigRecord entry) throws SQLException {
        MigRecord overrideEntry = findOverrideRecord(entry);
        MigRecord patch = findPatchRecord(entry);

        if (!Objects.isNull(overrideEntry) == Objects.isNull(patch))
            throw new IllegalArgumentException(String.format("File %s contains only one from override/patch files. These files should always exist together.", entry.script));

        if (checkMigrated(entry)) {
            log.info("DB migration already applied: {} {}", entry.rank, entry.script);
            applyMigrationPatch(entry, patch);
            return;
        }

        if (overrideEntry != null) {
            log.info("Detected override file. Attempt to apply {} instead of {}", overrideEntry.script, entry.script);
            if (checkMigrated(overrideEntry)) {
                log.info("DB migration override already applied: {} {}", overrideEntry.rank, overrideEntry.script);
                return;
            }
            entry = overrideEntry;
        }

        checkRank(entry);
        log.info("DB migration {} {} ..", entry.rank, entry.script);
        int delta = migrate(entry);
        log.info("DB migration performed: {} {} - execution time {}ms {}", entry.rank, entry.script, delta, entry.statements);
        if (!entry.isOverride())
            applyMigrationPatch(entry, patch);
    }

    protected void applyMigrationPatch(MigRecord entry, MigRecord patch) throws SQLException {
        if (patch == null)
            return;

        log.info("Detected patch file. Attempt to apply {}", patch.script);
        if (checkMigrated(patch)) {
            log.info("DB migration patch already applied: {} {}", patch.rank, patch.script);
            return;
        }
        log.info("DB migration patch {} {} ..", patch.rank, patch.script);
        int delta = migrate(patch);
        log.info("DB migration patch performed: {} {} - execution time {}ms {}", patch.rank, patch.script, delta, patch.statements);
    }

    private int migrate(MigRecord entry) throws SQLException {
        long now = System.currentTimeMillis();

        if (entry.language == MigRecord.Language.GROOVY) {
            runGroovyMigration(entry);
        } else {
            runSqlMigration(entry);
        }

        // compute the delta
        int delta = (int)(System.currentTimeMillis()-now);

        String columns = dialect.isPostgres()
                ? "rank, script, checksum, created_on, execution_time"
                : "`rank`,`script`,`checksum`,`created_on`,`execution_time`";
        // save the current migration
        final String insertSql = String.format("insert into %s (%s) values (?,?,?,?,?)", MIGTOOL_TABLE, columns);
        try (Connection conn=getConnection(); PreparedStatement insert = conn.prepareStatement(insertSql)) {
            insert.setInt(1, entry.rank);
            insert.setString(2, entry.script);
            insert.setString(3, entry.checksum);
            insert.setTimestamp(4, new Timestamp(now));
            insert.setInt(5, delta);
            insert.executeUpdate();
        }
        return delta;
    }

    protected boolean checkMigrated(MigRecord entry) {
        String sql;
        if(dialect.isPostgres()) {
            sql = "select id, checksum, script from " + MIGTOOL_TABLE + " where rank = ? and script = ?";
        } else {
            sql = "select `id`, `checksum`, `script` from " + MIGTOOL_TABLE + " where `rank` = ? and `script` = ?";
        }

        try (Connection conn=getConnection(); PreparedStatement stm = conn.prepareStatement(sql)) {
            stm.setInt(1, entry.rank);
            stm.setString(2, entry.script);

            ResultSet rs = stm.executeQuery();
            if( !rs.next() ) {
                return false;
            }
            // otherwise the checksum must match
            String checksum = rs.getString(2);
            if( checksum==null || !checksum.equals(entry.checksum) ) {
                throw new IllegalStateException("Checksum doesn't match for migration with name: " + entry.script) ;
            }
            return true;
        }
        catch (SQLException e) {
            throw new IllegalStateException("Unable validate migration -- cause: "+e.getMessage(), e);
        }
    }

    private void runSqlMigration(MigRecord entry) {
        // Apply all SQL migration statements
        for( String it : entry.statements ) {
            final long ts = System.currentTimeMillis();
            try (Connection conn = getConnection(5); Statement stm=conn.createStatement()) {
                stm.execute(it);
                log.debug("- Applied migration: {} elapsed time: {}ms", it, System.currentTimeMillis()-ts);
            }
            catch (SQLException e) {
                long delta = System.currentTimeMillis()-ts;
                String msg = "SQL MIGRATION FAILED - PLEASE RECOVER THE DATABASE FROM THE LAST BACKUP - Offending statement: "+it+" elapsed time: "+(delta)+"ms";
                throw new IllegalStateException(msg, e);
            }
        }
    }

    protected void runGroovyMigration(MigRecord entry) {
        final long ts = System.currentTimeMillis();

        try (Connection conn = getConnection()) {
            // Bind a `sql` variable, so it can be handled in scripts
            Sql sql = new Sql(conn);
            Binding binding = new Binding( Map.of("sql", sql) );
            GroovyShell shell = new GroovyShell(binding);

            // Run the script in a transaction in order to prevent inconsistent final states
            Closure<Object> closure = new Closure<Object>(null) {
                public Object doCall() {
                    return shell.evaluate(entry.statements.get(0));
                }
            };
            sql.withTransaction(closure);

        } catch (Exception e) {
            long delta = System.currentTimeMillis() - ts;
            String msg = "GROOVY MIGRATION FAILED - PLEASE RECOVER THE DATABASE FROM THE LAST BACKUP - Elapsed time: "+(delta)+"ms";
            throw new IllegalStateException(msg, e);
        }
    }

    public static class Builder {
        private String driverName;
        private Driver driver;
        private String url;
        private String user;
        private String password;
        private String dialectName;
        private Dialect dialect;
        private String locations;
        private ClassLoader classLoader;
        private Pattern pattern;

        public Builder withDriver(String driverName) {
            this.driverName = driverName;
            return this;
        }

        public Builder withUrl(String url) {
            this.url = url;
            return this;
        }

        public Builder withUser(String user) {
            this.user = user;
            return this;
        }

        public Builder withPassword(String password) {
            this.password = password;
            return this;
        }

        public Builder withDialect(String dialectName) {
            this.dialectName = dialectName;
            return this;
        }

        public Builder withLocations(String locations) {
            this.locations = locations;
            return this;
        }

        public Builder withClassLoader(ClassLoader loader) {
            this.classLoader = loader;
            return this;
        }

        public Builder withPattern(String pattern) {
            if(pattern != null && !pattern.isEmpty())
                this.pattern = Pattern.compile(pattern);
            return this;
        }

        public MigTool build() {
            if(driverName != null) {
                this.driver = Driver.fromDriverName(driverName);
            } else {
                this.driver = Driver.fromUrl(url);
            }
            if(dialectName != null) {
                this.dialect = Dialect.fromDialectName(dialectName);
            } else {
                this.dialect = Dialect.fromUrl(url);
            }
            return new MigTool(this);
        }
    }

}
